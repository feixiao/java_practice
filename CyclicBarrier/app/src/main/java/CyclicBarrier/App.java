/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package CyclicBarrier;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.CyclicBarrier;

// 这个程序中，我们创建了一个CyclicBarrier对象，它会等待所有线程都到达屏障点之后再执行某个任务。
// 我们创建了5个线程，每个线程会执行10个任务。每个线程执行完10个任务后，会调用await()方法等待其他线程到达屏障点。
// 当所有线程都到达屏障点之后，CyclicBarrier会执行一个任务，这里我们使用了一个ResultAggregator类来汇总结果。
// 最后，主线程等待所有子线程执行完毕后退出。

// 注意，这个示例程序并没有实际执行任务，因为任务的具体实现与题目相关，这里只是给出了一个框架。
public class App {

    private static final int NUM_THREADS = 5;
    private static final int NUM_TASKS = 10;

    public String getGreeting() {
        return "Hello World!";
    }

    public static void main(String[] args) {
        System.out.println(new App().getGreeting());

        // 编写程序使用CyclicBarrier 处理多线程任务，然后汇总结果
        // 1. 创建CyclicBarrier
        // 2. 创建多个线程
        // 3. 线程执行任务
        // 4. 线程汇总结果
        CyclicBarrier barrier = new CyclicBarrier(NUM_THREADS, new ResultAggregator());
        List<Thread> threads = new ArrayList<>();

        for (int i = 0; i < NUM_THREADS; i++) {
            threads.add(new Thread(new TaskRunner(barrier)));
        }

        for (Thread thread : threads) {
            thread.start();
        }

        // 捕获下面的异常，并处理

        for (Thread thread : threads) {
            try {
                thread.join();
            } catch (Exception e) {
                // TODO: handle exception
                System.out.println(e.toString());
            }

        }
    }
}
